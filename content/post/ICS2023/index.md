---
layout: post
title: 计算机系统基础 2023秋
---

# 第一章

## 冯·诺依曼结构

1. 基本思想：
    1. 采用"存储程序"工作方式
    2. 由`运算器`,`控制器`,`存储器`,`输入设备`,`输出设备`五个基本部件组成
    3. **存储器**不仅能放数据,还能放指令;形式上数据和指令没区别,但计算机能区分;**控制器**应能自动执行指令;**运算器**应能进行加减乘除四种基本算术运算,并且也能进行逻辑运算;操作人员通过**输入/输出设备**使用计算机
    4. 计算机内部以二进制形式表示指令和数据;每条指令由`操作码`和`地址码`两部分组成,`操作码`指出操作类型,`地址码`指出操作数地址;由一串`指令`组成`程序`
2. “存储程序”工作方式：任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令和执行指令的任
务。
3. 基本结构（下图）
4. 程序的执行过程
    1. 根据 PC 取指令
    2. 指令译码
    3. 取操作数并执行
    4. 回写结果
    5. PC增量

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled.png)

## 程序设计语言

1. 机器级语言：都属于低级语言，每条指令都与特定的机器结构相关
    1. 机器语言，机器代码：0/1序列，每条指令都由0/1组成
    2. 汇编语言：用英文符号和机器指令建立对应关系，源程序需要转换为机器语言程序才能被执行
2. 高级程序设计语言，高级编程语言：面向算法设计，与具体的机器结构无关

## 翻译程序

1. 汇编程序，汇编器：汇编语言源程序 → 机器语言目标程序
2. 解释程序，解释器：源程序逐条翻译成机器指令并立即执行
3. 编译程序，编译器：高级语言源程序 → 汇编 / 机器语言目标程序

> 掌握等价转换？
> 

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%201.png)

## 从源程序到可执行文件

1. 编译阶段：编译程序（`cc1`）对预处理后的源程序进行编译，生成一个汇编语言源程序，以 `.s` 为拓展名。
2. 汇编阶段：汇编程序（`as`）对汇编语言源程序进行汇编，生成一个可重定位目标文件，以 `.o` 为拓展名，是二进制文件，不可读。

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%202.png)

## 计算机系统的层次结构

1. 指令集体系结构（ISA）：是软件和硬件之间接口的一个完整定义，对指令系统的一种规范。内容包括：指令集、寄存器结构、存储空间和编址方式、数据存放方式、寻址方式、指令控制等。**定义了一台计算机可以执行的所有指令的集合。**

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%203.png)

# 第二章

## R 进制数和十进制数相互转换

1. →，按权展开；
2. ←，整数部分“除基取余”倒着写，小数部分“乘基取整”。

## 浮点数的表示（IEEE 754 标准）

掌握真值和机器码的转换。

1. 标准浮点数的表示：

$$
(-1)^s \times 1.f \times2^{e-127 \text{(单精度), 或}e- 1023\text{(双精度)}}
$$

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%204.png)

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%205.png)

## 数据类型的宽度 [](https://www.notion.so/3ee2750063064a4c8554ec763646446c?pvs=21)

| C 声明 | 32位 (typ) | 64位 |
| --- | --- | --- |
| char | 1 | 1 |
| short int | 2 | 2 |
| int | 4 | 4 |
| long int | 4 | 8 |
| char* | 4 | 8 |
| float | 4 | 4 |
| double | 8 | 8 |

## 数据的基本运算

### 左移和右移

1. 带符号使用算术移位，不考虑符号时使用逻辑移位。
2. 溢出：左移可能产生溢出。对于无符号数，如果左移移出了1，则溢出；对于有符号数，如果左移移出的位和新的符号位不同，则溢出。
3. 截断：右移可能发生有效数据丢失。 

### 整数加减运算

1. 输出标志：（$C$表示进位输出，$F$是运算结果）
    1. ZF，零标志：`ZF=1` 表示结果所有位都为0，否则为1；
    2. OF，溢出标志：同号相加符号位不变，否则溢出。即$\mathrm{OF}=C_n \oplus C_{n-1}$。
    3. SF，符号标志：即结果的符号位。
    4. CF，进 / 借位标志：加法若结果有进位，则为1；减法若不够减，则为1。即$\mathrm {CF} = \mathrm {Sub} \oplus C$。

### 常量的乘除运算

1. 使用移位、加法和减法的运算代替乘法运算能省时钟周期。一次乘法运算需要10个左右时钟周期，一次除法运算需要30个或更多时钟周期。

> 掌握计算省下了多少时钟周期？
> 

### 浮点数加减运算

1. 对阶：阶小的数右移，隐含的1需要被移出，空出的位补0。移出的位不丢，参与运算，保证精度。
2. 尾数加减：是原码运算，隐含的1和右移的附加位也参与运算。
3. 尾数规格化
4. 尾数舍入：中间结果右边至少保留两位。第一位为保护位，用于保护右移的位；第二位为舍入位，用于舍入。进一步提高计算精度，还引入粘位，只要舍入位右边还有数字，粘位被置1。（IEEE 754）
    1. 就近舍入到偶数（0舍1入）： $1.24... \times 10^4 \rightarrow 1.24 \times 10^4$
    2. 朝$+\infin$方向舍入。
    3. 朝$-\infin$方向舍入。
    4. 朝$0$方向舍入。
5. 阶码溢出判断：若右规后阶码全$1$，则发生阶码上溢，产生异常或可能被置为$+\infin$或$-\infin$；若左规后阶码全$0$，则发生阶码下溢，结果为非规格化形式。

### 浮点数乘除运算

和加减类似，但在进行运算前需要保证操作数为两个正常的规格化浮点数，计算步骤中不需要对阶。

## 需要注意的例题和课后题

- 大端、小端，数据在内存中存放的方式
- P33，进制转换
- P48，例2.23，例2.24
- P75，例2.36
- 课后题 9，23，24，28，34，35

# 第三章

课本的 RTL 规定：`R[r]` 表示寄存器的内容，`M[addr]` 表示存储单元`addr`的内容，寄存器`r`采用不带$\%$的形式表示；`M[PC]`表示`PC`所指存储单元的内容；`M[R[r]]`表示寄存器`r`的内容所指的存储单元的内容。传送方向用←表示。

> 不是重点，怕看混了
> 

## 数据类型及其格式 [](https://www.notion.so/4b1bd3ef2c5e48d4938d6865385366cf?pvs=21)

| C 声明 | Intel操作数类型 | 汇编指令长度后缀 | 存储长度（位）（IA-32） |
| --- | --- | --- | --- |
| (unsigned) char | 整数/字节 | b | 8 |
| (unsigned) short | 整数/字 | w | 16 |
| (unsigned) int | 整数/双字 | l | 32 |
| (unsigned) long int | 整数/双字 | l | 32 |
| (unsigned) long long int | — | — | 2 × 32 |
| char* | 整数/双字 | 4 | 32 |
| float | 单精度浮点数 | s | 32 |
| double | 双精度浮点数 | l | 64 |
| long double | 扩展精度浮点数 | t | 80 / 96 |

## IA-32常用指令

### 通用数据传送指令

传送寄存器或存储器中的**数据**。

- `MOV` ：`movb`，`movw`，`movl`
- `MOVS`：符号拓展传送指令，比如`movsbw` 表示符号拓展`s`一个字节`b` **数据**后传送到一个字`w`**地址**中。
- `MOVZ` ：零拓展传送指令。

栈：高地址向低地址增长，使用 ESP 寄存器（stack pointer）指向栈顶。

- `PUSH` ：先执行`R[sp] <- R[sp] - 2` （字）或`R[esp] <- R[esp] - 4` （双字），然后将一个字或者双字从指定寄存器送到 SP 或 ESP 指示的栈单元中。如`pushl` 表示双字压栈，`pushw` 表示字压栈。
- `POP` ：先将一个字或双字从 SP 或 ESP 指示的栈单元送到指定寄存器中，再执行`R[sp] <- R[sp] + 2` （字）或`R[esp] <- R[esp] + 4` （双字）。如`popl` 表示双字出栈，`popw` 表示字出栈。

### 地址传送指令

传送源操作数的**地址**，指定目的寄存器不能是段寄存器，且源操作数必须是存储器寻址方式。可以利用该指令进行运算。

- `LEA` （load effective address）

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%206.png)

### 定点算术运算指令

- `CMP` ：目的操作数减源操作数（AT&T右减左），只改变标志位

> 下面这四条只是怕忘蒽…
> 
- `INC`：加1，包括`incb`、`incw`、`incl`等
- `DEC`：减1，包括`decb`、`decw`、`decl`等
- `MUL` / `IMUL`：无符号乘 / 带符号乘
- `DIV`/ `IDIV`：带无符号除 / 带符号除。指令中只明显指出除数，使用`AL / AX / EAX` 中的内容除以除数。

### 按位运算指令

仅`NOT` 不影响条件标志位，其余指令执行后，$\mathrm{OF} = \mathrm{CF} = 0$，$\mathrm{ZF}$和$\mathrm{SF}$根据结果设置。

- `TEST`：两操作数相与，不改变原操作数。

### 移位指令

- `SHL/SHR`:  逻辑左/右移（无符号），包括 `shlb`、`shrw`、`shrl`等
- `SAL/SAR`:   算术左/右移（带符号），左移判溢出，右移高位补符，包括 `salb`、`sarw`、`sarl`等（移位前、后符号位发生变化，则 $\mathrm {OF}=1$ ）
- `ROL/ROR`：循环左/右移，包括 `rolb`、`rorw`、`roll`等
- `RCL/RCR`:   带进位循环左/右移，即：将$\mathrm {CF}$作为操作数一部分循环移位，包括 `rclb`、`rcrw`、`rcll`等

### 控制转移指令

四个标志位`c`、`z`、`s`、`o`；相等`e`；无符号数`a`（above）、`b`（below）；有符号数`g`（greater）、`l`（less）。

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%207.png)

## C 语言程序的机器级表示

### 过程调用的执行步骤（P为调用者，Q为被调用者）

现场即通用寄存器的内容。

1. P保存现场（必要时）；
2. 将入口参数（实参）放到Q能访问到的地方；
3. P保存返回地址，然后将控制转移到Q；（`CALL`）

以上三步为P栈帧。

1. Q保存P的现场，并为自己的非静态局部变量分配空间；（准备阶段）
2. 执行Q的过程体（函数体）；（处理阶段）
3. Q恢复P的现场，释放局部变量空间；
4. Q取出返回地址，将控制转移到P。（`RET`）

以上四步为Q栈帧。

### IA-32的寄存器使用约定

- 调用者保存寄存器：`eax`，`edx`，`ecx`
  
    如果调用函数P调用完Q返回后，还需用到`eax`寄存器，则需要P在调用Q前保存。一般而言P调用Q之后不需要用到`eax`寄存器，所以一般会将操作数优先存在`eax`，`edx`，`ecx`这类寄存器，以
    
- 被调用者保存寄存器：`ebx`，`esi`，`edi`
  
    如果被调用者Q需要用到`ebx`，则Q需要保存到栈中再使用。
    
- `ebp`：帧指针寄存器，指向当前栈帧底部，高地址
- `esp`：栈指针寄存器，指向当前栈帧顶部，低地址。

为减少准备和结束阶段的开销，每个过程应先使用`eax`，`edx`，`ecx`寄存器。

### 栈、栈帧

[栈：高地址向低地址增长，使用 ESP 寄存器（stack pointer）指向栈顶。](https://www.notion.so/ESP-stack-pointer-61c482857bf14f15b0940e4743533eb6?pvs=21) 

![pic10.png](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/pic10.png)

返回地址就是`call` 指令的下一条指令的地址。

![pic9.png](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/pic9.png)

### 变量的作用域和生存期

Q栈帧中保存的Q内部的非静态局部变量只在Q执行过程中有效。

> 结合栈的图
> 

![pic11.png](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/pic11.png)

> 准备参数入口，将值再复制了一遍是为什么？
假设回调函数为`swap(&t1,&t2)`，要改变局部变量的之前是不是得先存起来，不然令`t1=t2`，t1 原来的值消失了怎么办。
> 

### 按值传递参数和按地址传递参数

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%208.png)

i386中栈数据按4字节对齐，所以入口参数地址是`R[ebp]+8` 、`R[ebp]+12` 、`R[ebp]+16` 等等。`R[ebp]+4` 是返回地址。

## 复杂数据类型的分配和访问

### 数组

例如，`static short A[4];`要访问第`i`个元素，使用汇编指令`movw (%edx, %ecx, 2), %ax` 。由于是`short`类型，所以比例因子是2（2字节，1字）。其中，`ECX`为变址（索引）寄存器，在循环体中增量。

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%209.png)

### 数组与指针

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%2010.png)

### 结构体

结构型变量 `x` 各成员首址可用“基址加偏移量”的寻址方式。

![Untitled](%E4%B8%B2%E8%AE%B2%20772f161491d0457bbb703e098d8b6b60/Untitled%2011.png)

### 数据的对齐

最简单的对齐策略是，按其数据长度进行对齐，例如，`int`型地址是4的倍数，`short`型地址是2的倍数，`double`和`long long`型的是8的倍数，`float`型的是4的倍数，`char`不对齐。Windows采用该策略。

## x86-64

### 基本特点

- 字长从32位变为64位，64位（8B）数据被称为一个**四字**（`qw`: quadword）。指针（`char*`）和长整型（`long`）数据从32位拓展到64位。
- `long double`型数据虽然还采用80位（10B）扩展精度 格式，但所分配存储空间从 12B 扩展为 16B，即改为 16B 对齐方式，但不管是分配 12B 还是 16B，都只用到 低 10B。

## 需要注意的例题和课后题

- 汇编实验
- P105，例3.3
- P122，7；P124，8
- P150，例3.14
- 课后题，6，8，10，11，14，17，19，21，22，23，28